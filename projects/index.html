<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Nash Kaminski - Projects</title>
    <link rel="stylesheet" type="text/css" href="../assets/screen.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../assets/print.css" media="print">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0,shrink-to-fit=no" />
</head>
<body>
<h1>Projects</h1>
<nav>
<a href="../">About</a>
<a href="../projects">Projects</a>
<a href="../resume">Resume</a>
<a href="../sas">Sites and Systems</a>
</nav>
<hr>
<div class='projects'>
  <div id='hwsw'>
    <h1>General Hardware and Software</h1>
    <h5>Fueled by my curiosity and desire to learn, I have worked on countless small hardware and software projects, anything from one hour hacks to things that I have spent time on almost daily for weeks. Here are a few of which are worth mentioning.</h5>
      
      <h2>piProx</h2>
      <p>piProx is one of the artifacts of the combination of my curiosity as to the internals of RFID as well as the Linux Kernel. piProx is a Linux Kernel-mode driver for reading Weigand RFID reader signals via the GPIO pins, such as those found on the ubiquitous <a href="https://www.raspberrypi.org/">Raspberry Pi</a> or <a href="http://beagleboard.org/black">Beaglebone Black</a>. Being quite familiar with low level user land programming, I had always wanted to explore Linux at a lower level, more specifically how the Linux Kernel and associated device drivers interface with hardware. Furthermore, I had become interested in RFID and its uses and realized that writing a Linux Kernel driver for working with RFID devices was an excellent way to explore both areas while in the process creating something quite useful. My driver is implemented such that when it is loaded, it requests two GPIO pins from the GPIO subsystem, sets thier direction to input, requests interrupts on both of them as well as registers an interrupt handler for both the 1 bit line and the 0 bit line. Next, a character device named /dev/prox is created and registered with udev in order to provide an interface between this driver and the userland. During this entire process, the return codes of all steps are checked and the driver unloads itself cleanly if an error occurs during initialization. The character device provides an easy to use interface that returns either tha last scanned card if read in nonblocking mode or blocks until a card is scanned if read in blocking mode. In either case, the full binary data read from the card is returned to the reader including all parity bits. Additionally, via some cooperation with a very good friend of mine, <a href="http://peter.chinetti.me/">Peter Chinetti</a>, a series of userland tools were also developed to interpret the HID Corporate 1000 RFID card format and return the card number, facility code, and status of the parity/error detection computation.</p>
      
      <h2>Universal TTL serial -> RS485/DMX interface</h2>
      <figure>
      <img src="img/485_layout.jpg" alt="Layout of custom PCB" aria-labelledby="layoutlbl">  
      <figcaption id="layoutlbl">PCB layout</figcaption>
      </figure>
      <p>The initial inspiration for this project came from my prior interest and experience working with theatrical sound and lighting systems as well as my interest in having the best and most impressive holiday lighting system in the neighborhood. However, the cost of DMX lighting equipment, in particular the nicer control boards was easily in the thousands of dollars and therefore far outside of my approximately $200 per year budget. However, I was aware that DMX used RS-485 serial communication at the physical layer, and that the data link layer protocol was an open standard and therefore well documented, I decided to look into constructing an interface that would allow the TTL serial output of a low cost single board computer or microcontroller such as the <a href="https://www.arduino.cc/">Arduino</a>, <a href="https://www.raspberrypi.org/">Raspberry Pi</a> or <a href="http://beagleboard.org/black">Beaglebone Black</a> to drive an RS-485 physical link. Furthermore, the DMX data link layer protocol is fairly easily implemented in software and there already exists several implementations of such, including the UART native DMX plugin in <a href="http://opendmx.net/index.php/Open_Lighting_Architecture">Open Lighting Architecture for Linux</a> as well as the <a href="http://www.mathertel.de/Arduino/DMXSerial.aspx">DMXSerial</a> implementation for Arduino and other Atmel ATMEGA based microcontrollers. Furthermore, while there are a few preexisting open-source designs for serial to RS485 bridges, they are often lacking in areas that I consider very important such as voltage isolation, standard compliance, and cost. Therefore, I designed my own TTL serial to RS-485 interface around the Maxim MAX1480ACPI fully isolated RS-485 line driver IC as well as various 74 series CMOS logic IC's for signal conversion. This new interface is capable of receiving either a 3.3V or 5V input signal and can be configured to output both a 5V and 3.3V output signal. Additionally, the 3.3V output is designed as a tri-state output to ensure compatibility with the TI AM335x SoC's such as the ones found on the BeagleBoard and <a href="http://beagleboard.org/black">Beaglebone Black</a>. Hardware support is also provided for bidirectional communication and the output signal strength is strong enough to drive at a max data rate of 2Mbits/sec or at slower data rates over up to 1000ft of twisted pair cabling. Like nearly all of my other projects, this design is released as open source hardware and is <a href="https://github.com/nkaminski/Universal-RS485">available on my Github page</a>.</p>
  </div>
  <hr> 
  <div id="reveng">
    <h1>Reverse Engineering</h1>
    <h5>In general, I am a huge proponent of open source software and the use of open, well documented standards. However, there are times where there is something that I would like to accomplish that involves working with a proprietary or otherwise undocumented interface. In other cases, I am curious as to why some piece of hardware or software works internally. In any case, while often a very formidable engineering and problem solving task, it is often possible to gain a significant amount of insight into the inner workings of a given system via a variety of often rather complex techniques.</h5>
    <h2>Stratasys 3D Printer Network Protocol</h2>
    <p>During my time as a network engineer working for the IIT Idea Shop, I noticed that 3D printing on the Stratasys uPrint was an incredibly popular means of fabrication. Additionally, many complex jobs would often take several hours to complete and I noticed that there was continually a large number of inquiries as to the completion status of a given part or where a given job was in the machine's queue. Furthermore, the only means of interfacing with the machine was via a provided Windows application, which allowed users to upload jobs, as well as view the status of the machine and job queue. If this status information could be made easily available to users, for example via a web page, users would be able to access this info easily themselves. However, the network protocol used between the uPrint and its control program was proprietary and therefore completely undocumented. Therefore, it would be necessary to reverse engineer this network protocol in order to be able to extract the wanted data. I began the process by using Wireshark to capture the binary data of all network packets sent to and from the machine while the control software was running. The result of such was a large amount of data, most of which was sent to and from port 53742 on the machine. Some of the data, when interpreted as ASCII text, contained readable portions while other portions of the data contained seemingly random bytes. The question also remained how the protocol worked overall. After further analysis, it was noted that the protocol used a request/response system, where all commands and responses were null terminated C strings, padded to 64 bytes. The argument list was then terminated by sending the negative acknowledgement, NA. Furthermore, the commands were sent such that the command was sent first, then each of its arguments is sent in order as a separate 64 byte message. Once a full command and arguments was sent, the command and arguments were then sent back to the sender and had to be acknowledged individually with an acknowledgement, 'OK'. Furthermore, when a command is sent that will return more than 64 bytes, the machine will respond with a packet containing a string comprised of only digits. In this case, the numeric value of the string is the size of the data payload that is to be returned. If this is acknowledged by replying with 'OK', the next N bytes of data returned will be the data returned by the command. Putting this all together, sending the 'GetFile' command followed by the argument 'status.sts' and 'NA', replying OK to all responses and finally reading N bytes from the socket will result in a large blob of ASCII test, formatted in a means not terribly different from JSON, but too heavily mangled to fix using string operations. To solve this issue, a custom parser was developed and implemented in Python to parse the received data into a Python dict. Finally, the dict was re-serialized into proper JSON and the data was presented via a web page as well as in raw form via a RESTful service, allowing instant access to this data feed to all users of the prototyping lab without the need for manual intervention. I have also made the <a href='https://github.com/nkaminski/stratasys_api/'>code available via Github</a></p>
  </div>
  <hr>
  <div id='itr'>
    <h1>Illinois Tech Robotics</h1>
    <h5>Since my first week as a student at the Illinois Institute of Technology, I have taken part in the student organization <a href="https://illinoistechrobotics.org">Illinois Tech Robotics</a>. I first became interested in ITR because I really like building things and applying my knowledge as well as working with others while doing so. Throughout my time at IIT, I have worked on a plethora of projects in association with ITR and would like to highlight some of the best and most exciting.</h5>
  </div>
  
  <div>
    <h2>ITR Goliath</h2>
    <figure>
      <img src="img/itr-goliath.jpg" alt="Picture of ITR Golath in competition" aria-labelledby="itrgoliath_c">  
      <figcaption id="itrgoliath_c">2016 ITR Goliath - Photo credit Kori Bowns</figcaption>
    </figure>
    <p>ITR Goliath is a competitive robot designed to compete in the annual Midwest Regional Design Competition held at UIUC. When I first joined ITR, ITR Goliath was an inactive project with little more than a frame and a few small drive motors. I was very interested in leading and continuing the project with several other students who were also interested in starting an almost brand new project. At first it seemed like getting ITR Goliath competition ready would take a substantial amount of time. Furthermore, I quickly realized that while I was very confident in my knowledge of certain areas, such as electrical and software, while quite uncertain in others, namely mechanical. Therefore, I realized that it would take the efforts of a sizable group of individuals with knowledge and interests in a variety of disciplines in order to successfully overcome the engineering challenges present in such a design. Over the course of 4 competitions, some features of Goliath have changed significantly while others have remained relatively untouched, with Goliath performing better each time. Many of these decisions were influenced by new members joining the project and older members graduating as well as mainly by the lessons learned during the last competition. Things that worked well were rarely modified while areas were flaws were discovered were often reworked significantly. In 2014 and 2015, ITR Goliath won the final demolition round of the competition and in 2016 took first place in the competition.</p>
  </div>
  
  <div>
  <h2>Centrifugal Pumpkin Launcher</h2>
    <figure>
      <img src="img/itr-cforce.jpg" alt="Picture of fully assembled centrifugal pumpkin launcher" aria-labelledby="mach2">  
      <figcaption id="mach2">ITR Mach 2 Centrifugal Pumpkin Launcher</figcaption>
    </figure>
    <p>Each year during the fall, IIT's biomedical engineering society hosts a pumpkin launch competition where teams of students or alumni build machines to throw common pumpkins across the school's baseball field. The performance of the launchers is scored in 3 categories: distance, accuracy and crowd favorite. ITR has historically had some of the biggest and best performing launchers in the competition. In years past, many of ITR's launchers were variations of catapults. However, owing to the shift in ITR from mostly mechanical engineers to primarily computer engineers, we thought with our in depth knowledge and interest in computers and electronics that although it would be a massive engineering project, a computer driven pumpkin launcher could likely outperform the competing mechanical launchers with ease. After discussing the pros and cons of many designs, we settled on the centrifugal design. In a centrifugal launcher, both the rotational speed of the launch arm as well as release point during the rotation can be controlled via software, ideally allowing for excellent accuracy. Furthermore, unlike catapults which must impart all of the energy to the pumpkin within a matter of a fraction of a second, centrifugal launchers can add very large amounts of energy to the pumpkin slowly by spinning the arm progressively faster through many rotations before releasing. While the first couple revisions of this launcher did not quite perform as expected, they provided valuable insight into the design of <i>Mach 2</i> as well as taking 1st for accuracy the 2nd year. After analysing all of the shortcomings discovered in the early revisions of this launcher and determined to make this not just perform acceptably, but perform far better than any other design made, it was evident that more engineering as well as the contribution form a larger knowledge and interest base was needed. <i>Mach 2</i> was the product of the work of many interdisciplinary individuals incorporating newly acquired skills in design and simulation, as well as the lessons learned during past design revisions. The redesigned launcher stood 14 feet tall, was powered by a 5 horsepower industrial motor capable to spinning the arm to speeds in excess of 200 RPM, giving a release speed of upwards of 100 MPH. The computerized release system used an industrial optical encoder to track the position of the arm in its rotation to less than 1/2 of a degree and electrically triggered pneumatic release system to precisely release the over 1000lbs of tension on the pumpkin retaining straps at launch speed. This new design performed very well, with approximately 75% accuracy and winning ITR 1st place for distance and 2nd place for accuracy.</p>
  </div>
</div>
<script src="../assets/modernizr.js"></script>      
</body>
</html>
